---
title: "Package_Workflow"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Package_Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

### Introduction

The 'demulticoder' package is a robust DADA2 wrapper package for metabarcoding analyses. The package is designed for users with little experience doing metabarcoding analysis and a strength is the ability to to analyses on multiple datasets at once, different barcodes (not just ITS and 16S, but also rps10 for oomycete community analysis, as well as other barcodes, so long as the reference database is formatted like the UNITE fungal database).

The package was developed by Martha Sudermann, Zachary Foster, Niklaus Grunwald, Jeff Chang. Zachary Foster conceptualized much of the core workflow. 

### Before You Start

You will need to prepare your raw read files and fill in the 'metadata.csv' and 'primerinfo_params.csv' templates.

A strength of the package is that you can run multiple different datasets at once, which is shown in test dataset below. If samples contain pooled barcodes, you can also use the package to demultiplex and run analyses in tandem. S1 and S2 samples below illustrate this. Both samples contain rps10 and ITS pooled barcodes.

### Format of the Raw Read Files

The package takes foward and reverse Illumina short read sequence data.

To avoid errors, the only characters that are acceptable in sample names are letters and numbers. Characters can be separated by underscores, but no other symbols. The final characters before the '.fastq.gz' suffix MUST be '_R1' or '_R2'. 

Examples are permissible sample names are as follows:

* Sample1_R1.fastq.gz
* Sample1_R2.fastq.gz

Other permissible names are:

* Sample1_001_R1.fastq.gz
* Sample1_001_R2.fastq.gz

What is not permissible and will have to be renamed is:

* Sample1_001_R1_001.fastq.gz
* Sample1_001_R2_001.fastq.gz

The parsing functions will error out because the R1 and R2 are not directly preceeding the '.fastq.gz' suffix.

### Format of metadata file (*metadata.csv*)

The format of the CSV file is simple. The only two necessary columns (with these names) are:

1. sample_name column
2. primer_info column

Any additional metadata should then be pasted after these two columns. They can be referenced later during the analysis steps and save a step of loading metadata later.

S1 and S2 are come from a rhododendron rhizobiome dataset, and S3 and S4 come from an entirely different soil microbiome dataset but are used to illustrate that the package can also be used for 16S analyses.

You will notice S1 and S2 are included twice in the 'metadata.csv' sheet. This is because these two samples contain pooled reads (ITS and rps10). To demultiplex and run both analyses in tandem, include the same sample twice under sample_name, and then change the primer_name.

Example using test dataset:


sample_name,primer_name,well,organism
S1,rps10,A01,Cry
S2,rps10,B01,Cin
S1,its,A01,Cry
S2,its,B01,Cin
S3,sixteenS,NA,NA  
S4,sixteenS,NA,NA

### Primer sequence information and user-defined parameters are placed in *primerinfo_params.csv*

To simplify how functions are called, user will provide parameters within this input file. We recommend using the template provided in documentation. 

The only required columns user must fill in are:
1.primer_name (rps10, sixteenS, its, or other for another barcode)
2.forward-forward sequence
3.reverse-reverse sequence
4.already_trimmed (TRUE/FALSE)   

(Most datasets will require that primers first be removed from reads. However, for some 16S datasets, if protocols like the Earth Microbiome Project were followed, primers are mostly removed during the demultiplexing for barcoded samples following an Illumina run).  It may be that a few primers still remain.  If already_trimmed flag is specified, remaining primers will be removed and then reads for which no primers were located will be copied to the trimmed folder for subsequent analyses.  

If a user doesn't add any info to the subsequent columns, the default DADA2 parameters will be used. 

TODO-provide info on the different parameter descriptions and which functions they are associated with. 

Example template for 'primerinfo_params.csv'

primer_name,forward,reverse,already_trimmed,minCutadaptlength,multithread,verbose,maxN,maxEE_forward,maxEE_reverse,truncLen_forward,truncLen_reverse,truncQ,minLen,maxLen,minQ,trimLeft,trimRight,rm.lowcomplex,minOverlap,maxMismatch,min_asv_length
rps10,GTTGGTTAGAGYARAAGACT,ATRYYTAGAAAGAYTYGAACT,FALSE,100,TRUE,FALSE,1.00E+05,5,5,0,0,5,150,Inf,0,0,0,0,15,0,50
its,CTTGGTCATTTAGAGGAAGTAA,GCTGCGTTCTTCATCGATGC,FALSE,50,TRUE,FALSE,1.00E+05,5,5,0,0,5,50,Inf,0,0,0,0,15,0,50
sixteenS,GTGYCAGCMGCCGCGGTAA,GGACTACNVGGGTWTCTAAT,TRUE,0,TRUE,FALSE,1.00E+05,2,2,0,0,5,50,Inf,0,0,0,0,15,0,50


### Reference Database Format

For now, the package is compatible with the following databases:

* oomycetedb from: [http://www.oomycetedb.org/](http://www.oomycetedb.org/)

* SILVA 16S database with species assignments: [https://zenodo.org/records/4587955/files/silva_nr99_v138.1_wSpecies_train_set.fa.gz?download=1](https://zenodo.org/records/4587955/files/silva_nr99_v138.1_wSpecies_train_set.fa.gz?download=1)

* UNITE fungal database from [https://unite.ut.ee/repository.php](https://unite.ut.ee/repository.php)

A user can select up to one other database (for now), but will first need to reformat headers exactly like the UNITE fungal database specifications. 

Databases will be copied into the user-specified data folder where raw data files and csv files are located. The names will be parameters in the *assignTax* function

### Additional Notes

Computer specifications may be a limiting factor-- If you are using the SILVA or UNITE databases for taxonomic assignment steps, an ordinary personal computer (unless it has sufficient RAM) may not have enough memory for the taxonomic assignment steps, even with few samples. The test databases in the package are randomly subsetted for demonstration purposes. 

Users need to upload their own databases to their input data folder. If computer crashes during the taxonomic assignment step, please switch to a computing cluster.

Please also ensure that you have enough storage to save intermediate files in a temporary directory (default) or user-specified directory before proceeding.

### Loading the Package

For now, the package will be loaded by retrieving it from GitHub. Eventually, the package will be uploaded to CRAN or Bioconductor.
```{r installation, warnings=FALSE, message=FALSE}
#To pull from Github (Grunwald Lab members will need an auth_token as the package is currently private)
#library("devtools")
#devtools::install_github("grunwaldlab/demulticoder", auth_token="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", force=TRUE)
#library(demulticoder)

devtools::load_all("/Users/masudermann/demulticoder")
```

### Reorganize Data Tables
The sample names, primer sequences, and other metadata are reorganized in preparation for running Cutadapt to remove primers.
```{r prepare_reads function, message=FALSE}
demulticoder::prepare_reads(
  maxN = 0, 
  data_directory = system.file("extdata", package = "demulticoder"),
  output_directory = "~/output_test_dataset", 
  tempdir_id = "test_dataset_temp",
  overwrite_existing=TRUE)
```

### Remove Primers with Cutadapt
Before running Cutadapt, please ensure that you have installed it. 
```{r remove primers with cut_trim function, message=FALSE}
demulticoder::cut_trim(
  analysis_setup,
  cutadapt_path="/opt/homebrew/bin/cutadapt",
  overwrite_existing = TRUE)
```

### ASV inference step
Raw reads will be merged and ASVs will be inferred
```{r ASV inference, message=FALSE}
make_asv_abund_matrix(
  analysis_setup,
  overwrite_existing = TRUE)
```

### Taxonomic assignment step
Using the core assignTaxonomy function from DADA2, taxonomic assignments will be given to ASVs. 
```{r Assign taxonomy, message=FALSE}
assign_tax(
  analysis_setup,
  asv_abund_matrix,
  retrieve_files=TRUE,
  overwrite_existing=TRUE)
```

### Reformat ASV matrix as taxmap and phyloseq objects after optional filtering of low abundance ASVs
```{r Reformat final matrix, message=FALSE}
convert_asv_matrix_to_objs(save_outputs=TRUE, overwrite=TRUE)
```

### Now we demonstrate how to make a heattree using taxmap object. First we make a heat tree for our ITS-barcoded samples 
### Now we demonstrate how to make a heattree using taxmap object. First we make a heat tree for our ITS-barcoded samples
```{r Heatree demonstration its, message=FALSE}
load("~/demulticoder/inst/extdata/obj_dada_its.RData") 
obj_dada_its<-obj_dada

heat_tree(obj_dada_its,
          node_label = taxon_names,
          node_size = n_obs,
          node_color = n_obs,
          node_color_axis_label = "ASV count",
          node_size_axis_label = "Total Abundance of Taxa",
          layout = "da", initial_layout = "re")
```


### Now we demonstrate how to make a heattree using taxmap object. First we make a heat tree for our ITS-barcoded sample
```{r Heatree demonstration rps10, message=FALSE}
load("~/demulticoder/inst/extdata/obj_dada_rps10.RData") 
obj_dada_rps10<-obj_dada

heat_tree(obj_dada_rps10,
          node_label = taxon_names,
          node_size = n_obs,
          node_color = n_obs,
          node_color_axis_label = "ASV count",
          node_size_axis_label = "Total Abundance of Taxa",
          layout = "da", initial_layout = "re")
```

### We can also do a variety of analyses, if we convert to phyloseq object
```{r Phyloseq demonstration ITS, message=FALSE}
load("~/demulticoder/inst/extdata/phylo_obj_its.RData") 
phylo_data_its<-phylo_obj

data <- phylo_data_its %>%
  tax_glom(taxrank = "Genus") %>%                     
  transform_sample_counts(function(x) {x/sum(x)} ) %>% 
  psmelt() %>%                                        
  filter(Abundance > 0.02) %>%                      
  arrange(Genus)                                      

abund_plot <- ggplot(data, aes(x = Sample, y = Abundance, fill = Genus)) + 
  geom_bar(stat = "identity", position = "stack", color = "black", size = 0.2) +
  scale_fill_viridis_d() +
  scale_color_viridis_d() +
  theme_minimal() +
  labs(
    y = "Relative Abundance",
    title = "Relative abundance of taxa by sample",
    fill = "Genus"
  ) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 14),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "top",
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14),  # Adjust legend title size
    legend.key.size = unit(2, "lines"),  # Adjust the size of the legend color key
    strip.text = element_text(size = 14),
    strip.background = element_blank()
  ) +
  guides(
    fill = guide_legend(
      reverse = TRUE,
      keywidth = 1,
      keyheight = 1,
      title.position = "top",
      title.hjust = 0.5,  # Center the legend title
      label.theme = element_text(size = 10)  # Adjust the size of the legend labels
    )
  )

print(abund_plot)

```

```{r Phyloseq demonstration rps10, message=FALSE}
load("~/demulticoder/inst/extdata/phylo_obj_rps10.RData") 
phylo_data_rps10 <- phylo_obj

data <- phylo_data_rps10 %>%
  #tax_glom(taxrank = "Genus") %>%                     
  transform_sample_counts(function(x) {x/sum(x)} ) %>% 
  psmelt() %>%                                        
  filter(Abundance > 0.02) %>%                      
  arrange(Genus)                                      

abund_plot <- ggplot(data, aes(x = Sample, y = Abundance, fill = Genus)) + 
  geom_bar(stat = "identity", position = "stack", color = "black", size = 0.2) +
  scale_fill_viridis_d() +
  scale_color_viridis_d() +
  theme_minimal() +
  labs(
    y = "Relative Abundance",
    title = "Relative abundance of taxa by sample",
    fill = "Genus"
  ) +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5, size = 14),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "top",
    legend.text = element_text(size = 14),
    legend.title = element_text(size = 14),  # Adjust legend title size
    legend.key.size = unit(2, "lines"),  # Adjust the size of the legend color key
    strip.text = element_text(size = 14),
    strip.background = element_blank()
  ) +
  guides(
    fill = guide_legend(
      reverse = TRUE,
      keywidth = 1,
      keyheight = 1,
      title.position = "top",
      title.hjust = 0.5,  # Center the legend title
      label.theme = element_text(size = 10)  # Adjust the size of the legend labels
    )
  )

print(abund_plot)
```
